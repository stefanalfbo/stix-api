using System.Text.Json;
using MediatR;
using StixApi.Contracts.Persistance;
using StixApi.Domain.Entities;
using StixApi.Exceptions;
using StixApi.Persistance.Models;

namespace StixApi.Features.Vulnerabilities.Queries.Get.V1;

public class GetVulnerabilityQueryHandler : IRequestHandler<GetVulnerabilityQuery, VulnerabilityDetailDTO>
{
    private readonly IAsyncRepository<VulnerabilityDbModel> _vulnerabilityRepository;

    public GetVulnerabilityQueryHandler(IAsyncRepository<VulnerabilityDbModel> vulnerabilityRepository)
    {
        _vulnerabilityRepository = vulnerabilityRepository;
    }

    public async Task<VulnerabilityDetailDTO> Handle(GetVulnerabilityQuery request, CancellationToken cancellationToken)
    {
        var validator = new GetVulnerabilityQueryValidator();
        var validationResult = await validator.ValidateAsync(request, cancellationToken);
        if (!validationResult.IsValid)
        {
            throw new ValidationException(validationResult);
        }

        var vulnerabilityDbModel = await _vulnerabilityRepository.GetByIdAsync(request.Id);

        if (vulnerabilityDbModel == null)
        {
            throw new Exception("Vulnerability not found"); // Replace with a specific exception
        }

        var vulnerability = JsonSerializer.Deserialize<Vulnerability>(vulnerabilityDbModel.Value)
            ?? throw new JsonException("Failed to deserialize Vulnerability from JSON.");

        var vulnerabilityDetailDTO = new VulnerabilityDetailDTO
        {
            Type = vulnerability.Type,
            Id = vulnerability.Id,
            SpecificationVersion = vulnerability.SpecificationVersion,
            Created = vulnerability.Created.ToString("o"),
            Modified = vulnerability.Modified.ToString("o"),
            Name = vulnerability.Name,
            CreatedByRef = vulnerability.CreatedByRef,
            Revoked = vulnerability.Revoked,
            Labels = vulnerability.Labels,
            Confidence = vulnerability.Confidence,
            Language = vulnerability.Language,
            ExternalReferences = vulnerability.ExternalReferences?.Select(er => new ExternalReferenceDetailDTO
            {
                SourceName = er.SourceName,
                ExternalId = er.ExternalId,
                Description = er.Description,
                Url = er.Url,
                Hashes = er.Hashes,
            }).ToList(),
            ObjectMarkingRefs = vulnerability.ObjectMarkingRefs,
            GranularMarkings = vulnerability.GranularMarkings?.Select(gm => new GranularMarkingDetailDTO
            {
                Selectors = gm.Selectors,
                Language = gm.Language,
                MarkingRef = gm.MarkingRef,
            }).ToList(),
            Description = vulnerability.Description
        };

        return vulnerabilityDetailDTO;
    }
}