using FluentValidation;
using StixApi.Features.Vulnerabilities.Models;

namespace StixApi.Features.Vulnerabilities.Commands;

public class CreateVulnerabilityCommandValidator : AbstractValidator<CreateVulnerabilityCommand>
{
    public CreateVulnerabilityCommandValidator()
    {
        var externalReferencesValidator = new ExternalReferenceDTOValidator();
        var granularMarkingValidator = new GranularMarkingDTOValidator();

        RuleFor(v => v.Type)
            .NotEmpty().WithMessage("type is required")
            .Equal("vulnerability")
            .WithMessage("Type must be 'vulnerability'");

        RuleFor(v => v.SpecificationVersion)
            .NotEmpty().WithMessage("spec_version is required")
            .Must(v => v == "2.0" || v == "2.1")
            .WithMessage("spec_version must be either '2.0' or '2.1'");

        RuleFor(v => v.Id)
            .NotEmpty().WithMessage("id is required")
            .Matches(@"^vulnerability--[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
            .WithMessage("Id must follow the pattern: vulnerability--GUID");

        RuleFor(v => v.Created)
            .NotEmpty().WithMessage("created is required")
            .Matches("^[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?Z$")
            .WithMessage("created must be in RFC3339 format")
            .Must(dateString => DateTimeOffset.TryParse(dateString, out _))
            .WithMessage("created must be a valid RFC3339 timestamp");

        RuleFor(v => v.Modified)
            .NotEmpty().WithMessage("modified is required")
            .Matches("^[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?Z$")
            .WithMessage("modified must be in RFC3339 format")
            .Must(dateString => DateTimeOffset.TryParse(dateString, out _))
            .WithMessage("modified must be a valid RFC3339 timestamp")
            .Must((command, modified) =>
            {
                if (DateTimeOffset.TryParse(command.Created, out var createdDate) &&
                    DateTimeOffset.TryParse(modified, out var modifiedDate))
                {
                    return modifiedDate >= createdDate;
                }
                return true;
            })
            .WithMessage("modified date cannot be before created date");

        RuleFor(v => v.Name)
            .NotEmpty().WithMessage("name is required");
        //.MaximumLength(???).WithMessage("name must be less than ??? characters"); TODO: Define max length

        RuleFor(v => v.CreatedByRef)
            .Matches(@"^[a-z][a-z0-9-]+[a-z0-9]--[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
            .WithMessage("created_by_ref must follow the pattern: <the top-level object>--GUID")
            .When(v => !string.IsNullOrEmpty(v.CreatedByRef));

        RuleFor(v => v.Revoked)
            .Must(v => v == null || v == true || v == false)
            .WithMessage("revoked must be either true, false, or null");

        RuleFor(v => v.Labels)
            .Must(v => v == null || v.Count >= 1)
            .WithMessage("labels must contain at least one label")
            .When(v => v.Labels != null);

        RuleFor(v => v.Confidence)
            .Must(v => v == null || v >= 0 && v <= 100)
            .WithMessage("confidence must be between 0 and 100")
            .When(v => v.Confidence != null);

        RuleFor(v => v.Language)
            .NotEmpty().WithMessage("lang cannot be empty when provided")
            .When(v => v.Language != null);

        RuleForEach(v => v.ExternalReferences)
            .SetValidator(externalReferencesValidator)
            .When(v => v.ExternalReferences != null);

        RuleFor(v => v.ObjectMarkingRefs)
            .Must(v => v == null || v.Count >= 1)
            .WithMessage("object_marking_refs must contain at least one marking definition reference")
            .When(v => v.ObjectMarkingRefs != null);

        RuleForEach(v => v.ObjectMarkingRefs)
            .Matches(@"^[a-z][a-z0-9-]+[a-z0-9]--[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")
            .WithMessage("Each object_marking_refs item must follow the pattern: <the top-level object>--GUID")
            .When(v => v.ObjectMarkingRefs != null);

        RuleForEach(v => v.GranularMarkings)
            .SetValidator(granularMarkingValidator)
            .When(v => v.GranularMarkings != null);
    }
}