using System.Text.Json;
using MediatR;
using StixApi.Contracts.Persistance;
using StixApi.Domain.Common;
using StixApi.Domain.Entities;
using StixApi.Exceptions;
using StixApi.Persistance.Models;

namespace StixApi.Features.Vulnerabilities.Commands.Create.V1;

public class CreateVulnerabilityCommandHandler : IRequestHandler<CreateVulnerabilityCommand, string>
{
    private readonly IAsyncRepository<VulnerabilityDbModel> _vulnerabilityRepository;

    public CreateVulnerabilityCommandHandler(IAsyncRepository<VulnerabilityDbModel> vulnerabilityRepository)
    {
        _vulnerabilityRepository = vulnerabilityRepository;
    }

    public async Task<string> Handle(CreateVulnerabilityCommand request, CancellationToken cancellationToken)
    {
        var validator = new CreateVulnerabilityCommandValidator();
        var validationResult = await validator.ValidateAsync(request, cancellationToken);
        if (!validationResult.IsValid)
        {
            throw new ValidationException(validationResult);
        }

        var externalReferences = request.ExternalReferences?
            .Select(externalReference => new ExternalReference(
                externalReference.SourceName,
                externalReference.ExternalId,
                externalReference.Description,
                externalReference.Url,
                externalReference.Hashes?.ToDictionary(
                    hash => hash.Key,
                    hash => hash.Value
                ) ?? new Dictionary<string, string>()))
            .ToList() ?? new List<ExternalReference>();

        var granularMarkings = request.GranularMarkings?
            .Select(granularMarking => new GranularMarking(
                granularMarking.Selectors,
                granularMarking.MarkingRef,
                granularMarking.Language))
            .ToList() ?? new List<GranularMarking>();

        var vulnerability = new Vulnerability(
            request.Type,
            request.SpecificationVersion,
            request.Id,
            DateTime.Parse(request.Created),
            DateTime.Parse(request.Modified),
            request.Name,
            request.CreatedByRef,
            request.Revoked,
            request.Labels,
            request.Confidence,
            request.Language,
            externalReferences,
            request.ObjectMarkingRefs,
            granularMarkings,
            request.Description
        );

        var jsonDocument = JsonSerializer.SerializeToDocument(vulnerability);

        var vulnerabilityDbModel = new VulnerabilityDbModel
        {
            Id = request.Id,
            Value = jsonDocument
        };

        await _vulnerabilityRepository.AddAsync(vulnerabilityDbModel);
        return vulnerability.Id;
    }
}