using AutoMapper;
using NSubstitute;
using StixApi.Persistance.Models;
using StixApi.Features.Vulnerabilities.Commands;
using StixApi.Contracts.Persistance;
using StixApi.Profiles;
using Shouldly;

namespace StixApi.UnitTests.Vulnerabilities.Commands;

public class CreateVulnerabilityTests
{
    private readonly IMapper _mapper;

    private readonly CreateVulnerabilityCommand command = new CreateVulnerabilityCommand()
    {
        Type = "vulnerability",
        SpecificationVersion = "2.1",
        Id = "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6",
        Created = "2025-04-01T12:00:00Z",
        Modified = "2025-04-01T12:00:00Z",
        Name = "Test Vulnerability",
    };

    public CreateVulnerabilityTests()
    {
        var configurationProvider = new MapperConfiguration(cfg =>
            {
                cfg.AddProfile<MappingProfile>();
            });

        _mapper = configurationProvider.CreateMapper();
    }

    [Fact]
    public async Task Handle_Valid_Vulnerability()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert
        await _repositoryMock.Received(1)
            .AddAsync(
                Arg.Is<VulnerabilityDbModel>(v =>
                    v.Id == "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6"
                )
            );
    }

    [Fact]
    public async Task Handle_Invalid_Type()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Type = "invalid type";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_SpecificationVersion()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.SpecificationVersion = "1.9";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Id()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Id = "incident--1d555e17-e45e-43f7-9731-baa46d0bcbb6";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Created()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Created = "2025-13-01T12:00:00Z";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Modified()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Modified = "2025-10-42T12:00:00Z";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Modified_Before_Created()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.Created = "2025-04-01T12:00:00Z";
        invalidCommand.Modified = "2025-03-01T12:00:00Z";// Modified is before created


        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(command, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Empty_Name()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Name = "";

        // Act & Assert
        await Should.ThrowAsync<ArgumentException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }


}