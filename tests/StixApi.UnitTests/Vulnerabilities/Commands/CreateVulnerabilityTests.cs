using AutoMapper;
using NSubstitute;
using StixApi.Persistance.Models;
using StixApi.Contracts.Persistance;
using StixApi.Profiles;
using Shouldly;
using StixApi.Features.Vulnerabilities.Models;
using StixApi.Features.Vulnerabilities.Commands.Create.V1;
using StixApi.Exceptions;

namespace StixApi.UnitTests.Vulnerabilities.Commands;

public class CreateVulnerabilityTests
{
    private readonly IMapper _mapper;

    private readonly CreateVulnerabilityCommand command = new CreateVulnerabilityCommand()
    {
        Type = "vulnerability",
        SpecificationVersion = "2.1",
        Id = "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6",
        Created = "2025-04-01T12:00:00Z",
        Modified = "2025-04-01T12:00:00Z",
        Name = "Test Vulnerability",
    };

    public CreateVulnerabilityTests()
    {
        var configurationProvider = new MapperConfiguration(cfg =>
            {
                cfg.AddProfile<MappingProfile>();
            });

        _mapper = configurationProvider.CreateMapper();
    }

    [Fact]
    public async Task Handle_Valid_Vulnerability()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        // Act
        await handler.Handle(command, CancellationToken.None);

        // Assert
        await _repositoryMock.Received(1)
            .AddAsync(
                Arg.Is<VulnerabilityDbModel>(v =>
                    v.Id == "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6"
                )
            );
    }

    [Fact]
    public async Task Handle_Invalid_Type()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Type = "invalid type";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_SpecificationVersion()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.SpecificationVersion = "1.9";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Id()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Id = "incident--1d555e17-e45e-43f7-9731-baa46d0bcbb6";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Created()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Created = "2025-13-01T12:00:00Z";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Modified()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Modified = "2025-10-42T12:00:00Z";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Modified_Before_Created()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.Created = "2025-04-01T12:00:00Z";
        invalidCommand.Modified = "2025-03-01T12:00:00Z";// Modified is before created


        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(command, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Empty_Name()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Name = "";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_CreatedByRef()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.CreatedByRef = "invalid_ref";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Labels_When_Empty_Array()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        command.Labels = new List<string>();

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_Confidence()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.Confidence = 1337; // Invalid confidence value

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Valid_Confidence()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var validCommand = command;
        validCommand.Confidence = 85; // Valid confidence value

        // Act
        await handler.Handle(validCommand, CancellationToken.None);

        // Assert
        await _repositoryMock.Received(1)
            .AddAsync(
                Arg.Is<VulnerabilityDbModel>(v =>
                    v.Id == "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6"
                )
            );
    }

    [Fact]
    public async Task Handle_Invalid_Language()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.Language = "";

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_ExternalReferences()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.ExternalReferences = new List<ExternalReferenceDTO>
        {
            new ExternalReferenceDTO
            {
                SourceName = "Test Source",
            }
        };

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Invalid_ObjectMarkingRefs()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.ObjectMarkingRefs = new List<string>(); // Empty list not allowed

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Valid_ObjectMarkingRefs()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var validCommand = command;
        validCommand.ObjectMarkingRefs = new List<string> { "reference--1d555e17-e45e-43f7-9731-baa46d0bcbb6" };

        // Act
        await handler.Handle(validCommand, CancellationToken.None);

        // Assert
        await _repositoryMock.Received(1)
            .AddAsync(
                Arg.Is<VulnerabilityDbModel>(v =>
                    v.Id == "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6"
                )
            );
    }

    [Fact]
    public async Task Handle_Invalid_ObjectMarkingRefs_Format()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var invalidCommand = command;
        invalidCommand.ObjectMarkingRefs = new List<string> { "1d555e17-e45e-43f7-9731-baa46d0bcbb6" };

        // Act & Assert
        await Should.ThrowAsync<ValidationException>(async () =>
        {
            await handler.Handle(invalidCommand, CancellationToken.None);
        });
    }

    [Fact]
    public async Task Handle_Valid_GranularMarking()
    {
        // Arrange
        var _repositoryMock = Substitute.For<IAsyncRepository<VulnerabilityDbModel>>();
        var handler = new CreateVulnerabilityCommandHandler(_mapper, _repositoryMock);

        var validCommand = command;
        validCommand.GranularMarkings = new List<GranularMarkingDTO>
        {
            new GranularMarkingDTO
            {
                Selectors = new List<string> { "id" },
                Language = "en",
                MarkingRef = "marking-definition--0e1ea3ef-4046-48f2-8356-77ab0fe4847f"
            }
        };

        // Act
        await handler.Handle(validCommand, CancellationToken.None);

        // Assert
        await _repositoryMock.Received(1)
            .AddAsync(
                Arg.Is<VulnerabilityDbModel>(v =>
                    v.Id == "vulnerability--1d555e17-e45e-43f7-9731-baa46d0bcbb6"
                )
            );
    }

}